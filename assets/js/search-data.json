{
  
    
        "post0": {
            "title": "파이썬입문 겨울방학 특강 (4)",
            "content": "&#48136; . &#49888;&#54812;&#49440; . youtube: https://www.youtube.com/watch?v=ReKRSTB5PK8&amp;t=2s | . - 무슨말인지 하나도 몰랐어요 . - 요즘 학생들이 많이 쓰는 말인것은 알겠음 . - 멈춰까지 유행어였음!! (몰랐어요, 댓글보고 알았음) . &#47688;&#52656;? . Step1: 멈춰의 원조: 학교폭력, 멈춰~ . youtube: https://www.youtube.com/watch?v=aQyLhYC4E8Y | . Step2: 갑자기 뒤늦게 재미있음 $ to$ 밈화 . - 패러디 영상 . https://www.youtube.com/watch?v=lmkLZufjJS4&amp;list=PLSEouoj9wewjzMFrPKZPPUeMpn9Da_hSs&amp;index=8 | . - ㅇㅇㅇ, 멈춰~~~!로 따라하기 시작함 . 코스피하락, 멈춰~ | 세균, 멈춰~ | 수강신청 매크로, 멈춰~ | . &#48136;&#51060;&#46976; &#47924;&#50631;&#51064;&#44032;? . - 밈이란? 복제가능한 something . 이기적 유전자에서 제시한 개념 | 유전자는 (1) 복제 (2) 변형되면서 전파되는 속성이 있다는 사실을 관찰 | 종교, 사상, 이념도 유전자처럼 (1) 복제 (2) 변형되면서 전파되더라.. | 밈 = 유전자의 일반화된 개념 = 복제가능한 something | . &#48136;&#51012; &#52968;&#53584;&#52768;&#54868;&#54616;&#50668; &#48372;&#51088;. . - 예제1: 원본 . print(&quot;학교폭력&quot;) . 학교폭력 . from PIL import Image display(Image.open(&#39;2022-01-02-stop1.jpeg&#39;)) . print(&quot;멈춰~~~~~&quot;) . 멈춰~~~~~ . - 예제2: 코스피하락 . print(&quot;코스피하락,&quot;) . 코스피하락, . display(Image.open(&#39;2022-01-02-stop1.jpeg&#39;)) . print(&quot;멈춰~~~~~&quot;) . 멈춰~~~~~ . - 예제3: 수강신청 매크로 멈춰 . print(&quot;수강신청 매크로,&quot;) . 수강신청 매크로, . display(Image.open(&#39;2022-01-02-stop1.jpeg&#39;)) . print(&quot;멈춰~~~~~&quot;) . 멈춰~~~~~ . &#53076;&#46300;&#51032; &#51221;&#47532; . - 정리해보자. . start = &quot;학교폭력&quot; img = &#39;2022-01-02-stop1.jpeg&#39; end = &quot;멈춰~~~~~~~&quot; def memeshow(start, img, end): print(start) display(Image.open(img)) print(end) . - 예제1을 재생성 . memeshow(start,img,end) . 학교폭력 . 멈춰~~~~~~~ . - 예제2를 재생성 . start = &quot;코스피 하락,&quot; memeshow(start,img,end) . 코스피 하락, . 멈춰~~~~~~~ . - 예제3의 재생성 . start = &quot;수강신청 매크로,&quot; memeshow(start,img,end) . 수강신청 매크로, . 멈춰~~~~~~~ . &#53364;&#47000;&#49828;&#44032; &#50630;&#45796;&#47732;? . - 코드를 정리하다 보니까 살짝 비효율적인 느낌이 있음 . major: 여러개의 콘텐츠를 동시에 관리하기가 힘들다. | minor: start, img, end와 같은 변수들이 정리가 되어있지 않고 산만한 느낌이 든다. | . 부장님: 예제1을 생성하라 . start = &quot;학교폭력, &quot; memeshow(start,img,end) . 학교폭력, . 멈춰~~~~~~~ . 부장님: 예제2를 생성하라. . start = &quot;코스피하락,&quot; memeshow(start,img,end) . 코스피하락, . 멈춰~~~~~~~ . 부장님: 예제2에서 멈춰~ㅠㅠ 로 바꿔봐라. 좀 더 간절함이 느껴지도록.. . end = &quot;멈춰~~~ㅠㅠ&quot; memeshow(start,img,end) . 코스피하락, . 멈춰~~~ㅠㅠ . 부장님: OK 다시 예제1로 가봐 . start = &quot;학교폭력,&quot; memeshow(start,img,end) . 학교폭력, . 멈춰~~~ㅠㅠ . 부장님: 아니, 멈춰는 그대로 해야지. 여기서 우니까 애들이 더 괴롭힐것 같잖아 . end = &quot; 멈춰~~~~&quot; memeshow(start,img,end) . 학교폭력, . 멈춰~~~~ . 부장님: OK. 이제 이미지를 바꿔보자 신혜선 나오는것 어떰? 내가 신혜선 좋아함. . img = &#39;2022-01-02-stop2.png&#39; memeshow(start,img,end) . 학교폭력, . 멈춰~~~~ . 부장님: 좋다. 이제 2개의 컨텐츠를 동시에 보여봐. 점검을 해보자. . (예제1) . start= &quot;학교폭력,&quot; img = &quot;2022-01-02-stop2.png&quot; end = &quot;멈춰~~~~&quot; memeshow(start,img,end) . 학교폭력, . 멈춰~~~~ . (예제2) . start= &quot;코스피하락,&quot; img = &quot;2022-01-02-stop1.jpeg&quot; end = &quot;멈춰~~ㅜㅜ&quot; memeshow(start,img,end) . 코스피하락, . 멈춰~~ㅜㅜ . &#53364;&#47000;&#49828;&#51032; &#54876;&#50857; . - 클래스가 없다면? 살짝 비효율적인 느낌이 있음 . major: 여러개의 콘텐츠를 동시에 관리하기가 힘들다. (예제1, 예제2 동시에 관리하니까 힘들었어요) | minor: start, img, end와 같은 변수들이 정리가 되어있지 않고 산만한 느낌이 든다. | . - HWP를 켜서 부장님의 지시를 수행했다면? . 부장님의 공통 지시사항을 추린다. (start, img, end와 같은 요소가 필요하고 그림을 삽입하는 기술도 필요하겠음) | 소스가 되는 hwp파일을 하나 만든다. 복사를 위한 틀이다. 파일이름은 KBS.HWP라고 하자. | KBS.HWP파일을 복사 $ to$ stop1.hwp, stop2.hwp 파일을 만든다. 그리고 부장님이 지시사항이 있을때마다 stop1.hwp, stop2.hwp의 내용을 각각 수정한다. | . - 단점이 극복될까요? . major: 여러개의 콘텐츠를 동시에 관리하기가 힘들다. $ to$ 샘플파일과 각각의 복사본을 나누어서 독립적으로 관리하므로 이 문제는 해결 | minor: start, img, end와 같은 변수들이 정리가 되어있지 않고 산만한 느낌이 든다. $ to$ stop1.hwp, stop2.hwp와 같은파일안에 내용이 있으므로 산만하지 않음. | . - 방금 말한 HWP와 같은 방식을 코딩에 적용해보자. . class KBSHWP: start = &#39;학교폭력,&#39; img = &#39;2022-01-02-stop1.jpeg&#39; end = &#39;멈춰~~~~&#39; def memeshow(self): ## 규칙1: class안에 정의된 함수의 첫번째 인자는 무조건 self print(self.start) ## 규칙2: class안에 정의된 변수를 쓰려면 self.변수이름 과 같은 형식으로 써야함 display(Image.open(self.img)) # 규칙2 적용 print(self.end) # 규칙2 적용 . 부장님: 예제1을 생성하라 . stop1 = KBSHWP() . stop1.memeshow() . 학교폭력, . 멈춰~~~~ . 부장님: 예제2를 생성하라. . stop2 = KBSHWP() stop2.start = &#39;코스피하락,&#39; stop2.memeshow() . 코스피하락, . 멈춰~~~~ . 부장님: 예제2에서 멈춰~ㅠㅠ 로 바꿔봐라. 좀 더 간절함이 느껴지도록.. . stop2.end = &#39;멈춰~ㅠㅠ&#39; stop2.memeshow() . 코스피하락, . 멈춰~ㅠㅠ . 부장님: OK 다시 예제1로 가봐 . stop1.memeshow() . 학교폭력, . 멈춰~~~~ . 부장님: 아니, 멈춰는 그대로 해야지. 여기서 우니까 애들이 더 괴롭힐것 같잖아 . 부장님: OK. 이제 이미지를 바꿔보자 신혜선 나오는것 어떰? 내가 신혜선 좋아함. . stop1.img = &#39;2022-01-02-stop2.png&#39; stop1.memeshow() . 학교폭력, . 멈춰~~~~ . 부장님: 좋다. 이제 2개의 컨텐츠를 동시에 보여봐. 점검을 해보자. . (예제1) . stop1.memeshow() . 학교폭력, . 멈춰~~~~ . (예제2) . stop2.memeshow() . 코스피하락, . 멈춰~ㅠㅠ . &#53364;&#47000;&#49828;&#44277;&#48512; 1&#45800;&#44228; . &#53364;&#47000;&#49828;&#51032; &#49457;&#45733; . 성능1: 틀만있으면 여러개의 독립적인 컨텐츠를 생성할 수 있다. . stop1 = KBSHWP() stop2 = KBSHWP() . 성능2: 생성된 컨텐츠(=인스턴스, 오브젝트)에서 .을 찍고 접근할 수 있는 여러 자료들에 접근가능하고 그 내용물도 바꿀 수 있다. . stop2.start . &#39;학교폭력,&#39; . stop2.start = &#39;코스피하락,&#39; stop2.start . &#39;코스피하락,&#39; . 성능3: 생성된 컨텐츠(=인스턴스, 오브젝트)에서 .을 찍고 쓸 수 있는 자체적인 함수(=메소드)를 독립적으로 사용할 수 있다. . stop1.memeshow() . 학교폭력, . 멈춰~~~~ . 성능 4,5,6.... 그 밖의 미공개된 성능이 많음 . &#53364;&#47000;&#49828; &#49324;&#50857;&#48277; (&#50516;&#44592;) . - 선언하는 방법 (= 양식문서를 만드는 방법) . class KBSHWP: ## 양식의 이름을 설정 start = &#39;학교폭력,&#39; ## 양식에 포함된 변수 1 img = &#39;2022-01-02-stop1.jpeg&#39; ## 양식에 포함된 변수2 end = &#39;멈춰~~~~&#39; ## 양식에 포함된 변수3 def memeshow(self): ## 양식에 포함된 함수1 = 메소드1 print(self.start) display(Image.open(self.img)) print(self.end) . 규칙1: 메소드(=class안에서 정의된 함수)의 첫번째 인자는 무조건 self | 규칙2. 메소드에서 class안에서 정의된 변수를 사용하려면 self.변수이름과 같은 꼴로 써야한다. self.start, self.img, self.end와 같은 방식으로 써야 한다. | KBSHWP.start, KBSHWP.img, KBSHWP.end 와 같은 방식으로 쓰는 경우도 가끔있다. (필요에 따라) | . | . - 성능1을 사용하는 방법: 클래스에서 인스턴스를 생성하는 방법 . stop1 = KBSHWP() ## stop2 = KBSHWP() . 함수사용법이랑 비슷 | 클래스 이름을 쓰고 콘텐츠를 구체화하는 과정에서 필요한 입력1, 필요한 입력2 를 ()에 넣는다. | 현재는 따로 들어가는 입력이 없으므로, 그냥 KBSHWP 이후에 입력을 비워둔다. 즉 KBSHWP()로 생성. | . - 성능2를 사용하는 방법: 인스턴스에서 .을 찍고 접근하고 싶은 속성에 접근, 혹은 변경 . stop2.start . &#39;학교폭력,&#39; . stop2.start = &#39;코스피하락,&#39; stop2.start . &#39;코스피하락,&#39; . - 성능3을 사용하는 방법: 인스턴스에서 .을 찍고 사용하고 싶은 메소드를 사용 . stop2.memeshow() . 학교폭력, . 멈춰~~~~ . &#50672;&#49845;&#47928;&#51228; . &#47928;&#51228;1: &#44053;&#51032;&#45432;&#53944;&#47484; &#52280;&#44256;&#54616;&#50668; &#50500;&#47000;&#51032; &#44592;&#45733;&#51012; &#44032;&#51652; &#53364;&#47000;&#49828;&#47484; &#44396;&#54788;&#54616;&#46972;. &#53364;&#47000;&#49828; &#51060;&#47492;&#51008; KBSHWP2&#47196; &#54616;&#46972;. . class KBSHWP2: title = &#39;[컨텐츠1]&#39; start = &#39;학교폭력,&#39; img = &#39;2022-01-02-stop1.jpeg&#39; end = &#39;멈춰~~~~&#39; def memeshow(self): print(self.title) print(self.start) display(Image.open(self.img)) print(self.end) . stop3=KBSHWP2() . stop3.memeshow() . [컨텐츠1] 학교폭력, . 멈춰~~~~ . &#47928;&#51228;2: &#50500;&#47000;&#50752; &#44057;&#51008; &#53364;&#47000;&#49828;&#47484; &#44396;&#54788;&#54616;&#46972;. . - 클래스내에는 변수 a가 있다. 변수 a의 초기값은 True이다. . - 클래스에는 show()라는 메소드가 있다. show()의 기능은 a값을 출력하는 것이다. . (풀이) . class AAAA: a= True def show(self): print(self.a) . aaaa = AAAA() . aaaa.a . True . aaaa.show() . True . aaaa.a = False . aaaa.show() . False . &#47928;&#51228;3: &#50500;&#47000;&#50752; &#44057;&#51008; &#44592;&#45733;&#51012; &#44032;&#51648;&#45716; &#53364;&#47000;&#49828;&#47484; &#44396;&#54788;&#54616;&#46972;. . - 클래스내에는 변수 a가 있다. 변수 a의 초기값은 1이다. . - 클래스에는 up()이라는 메소드를 가지고 있다. 이 메소드의 기능은 a의 값을 1증가시키는 것이다. . (풀이) . class Temp: a= 1 def up(self): self.a=self.a+1 . temp= Temp() . temp.a . 1 . temp.up() . temp.a . 2 . &#47928;&#51228;4: &#50500;&#47000;&#50752; &#44057;&#51008; &#44592;&#45733;&#51012; &#44032;&#51652; &#53364;&#47000;&#49828;&#47484; &#44396;&#54788;&#54616;&#46972;. . - 클래스내에는 변수a가 있다. 변수a의 초기값은 0이다. . - 클래스에는 up(), down(), show() 라는 메소드가 있다. 각각의 기능 a의 값을 1증가, 1감소, 출력 하는 기능을 가진다. . (힌트) . class Temp2: a = 0 def up(self): self.a= self.a+1 def down(self): self.a = self.a-1 def show(self): print(self.a) . temp = Temp2() . temp.a . 0 . temp.down() . temp.show() . -1 . temp.up() . temp.up() . temp.show() . 1 . &#47928;&#51228;5: &#50500;&#47000;&#50752; &#44057;&#51008; &#44592;&#45733;&#51012; &#44032;&#51648;&#45716; &#53364;&#47000;&#49828;&#47484; &#44396;&#54788;&#54616;&#46972;. . - 기능1: 2022-01-02-stop1.jpeg을 보여줌 . - 기능2: 당신은 이 그림을 n번 보았습니다.를 출력 여기에서 $n$은 그림을 본 횟수 . class Temp3: n=1 img= &#39;2022-01-02-stop1.jpeg&#39; def show(self): display(Image.open(self.img)) print(&#39;당신은 이그림을 %s 번 보았습니다&#39; % self.n) self.n=self.n+1 . temp3 = Temp3() . temp3.show() . 당신은 이그림을 1 번 보았습니다 . temp3.show() . 당신은 이그림을 2 번 보았습니다 . temp3.show() . 당신은 이그림을 3 번 보았습니다 . temp4 = Temp3() . temp4.img = &#39;2022-01-02-stop2.png&#39; . temp4.show() . 당신은 이그림을 1 번 보았습니다 . temp4.show() . 당신은 이그림을 2 번 보았습니다 . temp3.show() . 당신은 이그림을 4 번 보았습니다 . temp4.show() . 당신은 이그림을 3 번 보았습니다 .",
            "url": "https://guebin.github.io/IP2022WIN/2022/01/04/WINIP4.html",
            "relUrl": "/2022/01/04/WINIP4.html",
            "date": " • Jan 4, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "파이썬입문 겨울방학 특강 (3)",
            "content": "import . import numpy as np . numpy&#44277;&#48512; 1&#45800;&#44228;(&#48373;&#49845;) . - 넘파이의 위력 . l=[1,2,3] a=np.array(l) ## list() . - 사칙연산 브로드캐스팅 . a+1 . array([2, 3, 4]) . l+1 . TypeError Traceback (most recent call last) &lt;ipython-input-9-558f50c77660&gt; in &lt;module&gt; -&gt; 1 l+1 TypeError: can only concatenate list (not &#34;int&#34;) to list . a*2 . array([2, 4, 6]) . l*2 . [1, 2, 3, 1, 2, 3] . a-2 . array([-1, 0, 1]) . l-2 . TypeError Traceback (most recent call last) &lt;ipython-input-13-a7ce880f546b&gt; in &lt;module&gt; -&gt; 1 l-2 TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;int&#39; . a/2 . array([0.5, 1. , 1.5]) . l/2 . TypeError Traceback (most recent call last) &lt;ipython-input-15-156c9f11ad90&gt; in &lt;module&gt; -&gt; 1 l/2 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . - 기타수학연산가능 . np.sqrt(a), np.sqrt(l) . (array([1. , 1.41421356, 1.73205081]), array([1. , 1.41421356, 1.73205081])) . np.log(a), np.log(l) . (array([0. , 0.69314718, 1.09861229]), array([0. , 0.69314718, 1.09861229])) . numpy&#44277;&#48512; 2&#45800;&#44228; . &#50672;&#47549;1&#52264;&#48169;&#51221;&#49885;&#51032; &#54400;&#51060; . - 아래의 연립방정식 고려 . $ begin{cases} x + y = 2 y + z = 2 x + z = 2 end{cases}$ . - 행렬표현은? . $ begin{bmatrix} 1 &amp;1&amp; 0 0 &amp; 1 &amp; 1 1 &amp; 0 &amp; 1 end{bmatrix} begin{bmatrix} x y z end{bmatrix} = begin{bmatrix} 2 2 2 end{bmatrix} $ . A = [[1,1,0],[0,1,1],[1,0,1]] A . [[1, 1, 0], [0, 1, 1], [1, 0, 1]] . A2=np.array(A) A2 . array([[1, 1, 0], [0, 1, 1], [1, 0, 1]]) . - A의 원소인덱싱 . A[0][0], A[0][1], A[0][2] . (1, 1, 0) . A[1][0], A[1][1], A[1][2] . (0, 1, 1) . A[2][0], A[2][1], A[2][2] . (1, 0, 1) . - A2에서의 원소인덱싱 . A2[0][0], A2[0][1], A2[0][2] . (1, 1, 0) . A2[1][0], A2[1][1], A2[1][2] . (0, 1, 1) . A2[2][0], A2[2][1], A2[2][2] . (1, 0, 1) . - A2에서의 원소에 접근하는 또다른 방법 (numpy 신기술) . A2[0,0], A2[0,1], A2[0,2] . (1, 1, 0) . A2[1,0], A2[1,1], A2[1,2] . (0, 1, 1) . A2[2,0], A2[2,1], A2[2,2] . (1, 0, 1) . - 슬라이싱! . A2[0,:] ## R의 경우라면 A2[0,] . array([1, 1, 0]) . A2[1,:] . array([0, 1, 1]) . A2[2,:] . array([1, 0, 1]) . - 연립방정식 문제를 다시 풀어보자. . $ begin{bmatrix} 1 &amp; 1 &amp; 0 0 &amp; 1 &amp; 1 1 &amp; 0 &amp; 1 end{bmatrix} begin{bmatrix} x_1 x_2 x_3 end{bmatrix} = begin{bmatrix} 2 2 2 end{bmatrix} quad Longleftrightarrow quad { bf A} { bf x} = { bf b} $ . b=np.array([2,2,2]) . np.linalg.inv(A2) @ b ## R로 치면 solve(A2) %*% b . array([1., 1., 1.]) . &#51064;&#45937;&#49905; . - 선언 . l=[11,22,33,44,55,66] a=np.array(l) a . array([11, 22, 33, 44, 55, 66]) . - 인덱스로 접근 . l[0],l[1],l[2],l[3],l[4],l[5] . (11, 22, 33, 44, 55, 66) . a[0],a[1],a[2],a[3],a[4],a[5] . (11, 22, 33, 44, 55, 66) . - : 이용 (슬라이싱) . l[2:4] # index=2, index=3 (4는 포함되지 않음) . [33, 44] . a[2:4] . array([33, 44]) . 너무 헷갈림.. 특히 마지막 원소를 포함해야할때! . l[2:6] . [33, 44, 55, 66] . a[2:6] . array([33, 44, 55, 66]) . 다행스럽게도 마지막의 6은 생략가능하다. 따라서 보통 아래와 같이 쓴다. . l[2:] . [33, 44, 55, 66] . a[2:] . array([33, 44, 55, 66]) . 동일한 논리로 처음 인덱스도 생략가능하다. . a[0:3], a[:3] . (array([11, 22, 33]), array([11, 22, 33])) . 처음과 마지막을 둘다 생략한다면? . a[:] . array([11, 22, 33, 44, 55, 66]) . - 부울값을 이용한 인덱싱 . l=[11,22,33,44,55,66] a=np.array(l) a . array([11, 22, 33, 44, 55, 66]) . a[ [False, True, False, True, False, True] ] . array([22, 44, 66]) . a&lt;33 . array([ True, True, False, False, False, False]) . a[a&lt;33] . array([11, 22]) . 리스트는 안된다. . l&lt;33 ## 일단 여기서 막힘 . TypeError Traceback (most recent call last) &lt;ipython-input-74-0617af835ebc&gt; in &lt;module&gt; -&gt; 1 l&lt;33 ## 일단 여기서 막힘 TypeError: &#39;&lt;&#39; not supported between instances of &#39;list&#39; and &#39;int&#39; . reshape . - reshape . l = [11,22,33,44,55,66] a = np.array(l) a . array([11, 22, 33, 44, 55, 66]) . a.reshape(2,3) . array([[11, 22, 33], [44, 55, 66]]) . a ## reshape은 a자체가 변화하지 않음 . array([11, 22, 33, 44, 55, 66]) . b = a.reshape(2,3) b . array([[11, 22, 33], [44, 55, 66]]) . - b를 다시 a처럼 바꾸고 싶다면? . b.reshape(6) . array([11, 22, 33, 44, 55, 66]) . b.flatten() . array([11, 22, 33, 44, 55, 66]) . b.ravel() . array([11, 22, 33, 44, 55, 66]) . b.reshape(-1) . array([11, 22, 33, 44, 55, 66]) . numpy&#44277;&#48512; 3&#45800;&#44228; . - 2차원 array a,b를 선언하자. . a=np.array([[11,22,33,44]]).reshape(2,2) a . array([[11, 22], [33, 44]]) . b=np.array([[11,22,33,44,55,66]]).reshape(2,3) b . array([[11, 22, 33], [44, 55, 66]]) . - a. + TAB, b. + TAB . a.shape, b.shape . ((2, 2), (2, 3)) . a.size, b.size . (4, 6) . a.itemsize, b.itemsize . (8, 8) . ? | . a.strides, b.strides . ((16, 8), (24, 8)) . ? | . a의 형태 . a . array([[11, 22], [33, 44]]) . b의 형태 . b . array([[11, 22, 33], [44, 55, 66]]) . - itemsize와 strides의 의미를 유추하기 위해서 c,d를 더 만들어보자. . c = np.array([11,22,33,44]).reshape(4,1) d = np.array([11,22,33,44]) . c의 형태 . c . array([[11], [22], [33], [44]]) . d의 형태 . d . array([11, 22, 33, 44]) . - a,b,c,d 속성비교 . a.shape, b.shape, c.shape, d.shape ## 차원 . ((2, 2), (2, 3), (4, 1), (4,)) . a.size, b.size, c.size, d.size ## 원소의 수 . (4, 6, 4, 4) . a.itemsize, b.itemsize, c.itemsize, d.itemsize ## 항상 8? . (8, 8, 8, 8) . a.strides, b.strides, c.strides, d.strides ## 차원이랑 관련이 있어보임.. + 8의 배수 . ((16, 8), (24, 8), (8, 8), (8,)) . a . array([[11, 22], [33, 44]]) . - itemsize, strides는 무엇? . itemsize: 숫자하나를 저장하는 필요한 메모리 공간 | strides: (다음 행으로 가기위해서 JUMP해야하는 메모리 공간수, 다음 열로 가기위해서 JUMP해야하는 메모리 공간수) | . - strides에 대한 추가해설 . (오브젝트b) . b . array([[11, 22, 33], [44, 55, 66]]) . b.reshape(-1) . array([11, 22, 33, 44, 55, 66]) . b.strides . (24, 8) . - itemsize는 항상 8이다? . e=np.array([11,22,33,44,55,66],dtype=&#39;int32&#39;) e . array([11, 22, 33, 44, 55, 66], dtype=int32) . e.itemsize . 4 . e=e.reshape(2,3) e . array([[11, 22, 33], [44, 55, 66]], dtype=int32) . e.strides . (12, 4) . &#52280;&#51312; . - a를 선언, b는 a의 참조 . a=np.array([[1,2],[3,4]]) b=a ## 참조 . a . array([[1, 2], [3, 4]]) . b . array([[1, 2], [3, 4]]) . a.shape . (2, 2) . b.shape . (2, 2) . - a의 shape을 바꾸어보자 $ to$ b도 같이 바뀐다 . a.shape = (4,) . a . array([1, 2, 3, 4]) . b . array([1, 2, 3, 4]) . id(a),id(b) . (139811809650992, 139811809650992) . view . - a를 선언, b는 a의 view . a=np.array([[1,2],[3,4]]) b=a.view() ## shallow copy . a . array([[1, 2], [3, 4]]) . b . array([[1, 2], [3, 4]]) . a.shape . (2, 2) . b.shape . (2, 2) . a.shape= (4,1) . a . array([[1], [2], [3], [4]]) . b . array([[1, 2], [3, 4]]) . id(a), id(b) . (139811818705616, 139811818705424) . - 그런데.. . a[0]=100 . a . array([[100], [ 2], [ 3], [ 4]]) . b . array([[100, 2], [ 3, 4]]) . - 출생의 비밀 . b . array([[100, 2], [ 3, 4]]) . b.base . array([[100], [ 2], [ 3], [ 4]]) . ? 이거 바뀐 a아니야? | . id(b.base) . 139811818705616 . id(a) . 139811818705616 . - View . b가 a의 뷰라는 의미는, b가 a를 소스로하여 만들어진 오브젝트란 의미이다. | 따라서 이때 b.base는 a가 된다. | b는 자체적으로 데이터를 가지고 있지 않으며 a와 공유한다. | 이러한 의미에서 view를 shallow copy 라고 부른다. (가장 껍데기 구조만 복사하므로) | . note1 원본 ndarray의 일 경우는 .base가 None으로 나온다. . a.base . note2 b.base의 shpae과 b의 shape은 아무 관련없다. . b.shape . (2, 2) . b.base.shape . (4, 1) . copy . - a를 선언, b는 a의 copy . a=np.array([[1,2],[3,4]]) b=a.copy() . id(a),id(b) . (139811818708208, 139811818707344) . - a의 shape을 바꿔도 b에는 적용되지 않음 . a.shape = (4,1) a . array([[1], [2], [3], [4]]) . b . array([[1, 2], [3, 4]]) . - 그리고 a[0]의 값을 바꿔도 b에는 적용되지 않음. . a[0]=100 . a . array([[100], [ 2], [ 3], [ 4]]) . b . array([[1, 2], [3, 4]]) . - b의 출생을 조사해보니.. . a.base,b.base . (None, None) . 출생의 비밀은 없었다. 둘다 원본. . .copy의 한계(?) . a=np.array([1,[1,2]],dtype=&#39;O&#39;) a . array([1, list([1, 2])], dtype=object) . b=a.copy() . b . array([1, list([1, 2])], dtype=object) . a[0]=222 . a . array([222, list([1, 2])], dtype=object) . b . array([1, list([1, 2])], dtype=object) . a[1][0]=333 . a . array([222, list([333, 2])], dtype=object) . b . array([1, list([333, 2])], dtype=object) . 해결책: 더 깊은 복사 . import copy . a=np.array([1,[1,2]],dtype=&#39;O&#39;) b=copy.deepcopy(a) . a . array([1, list([1, 2])], dtype=object) . b . array([1, list([1, 2])], dtype=object) . a[0]=100 . a,b . (array([100, list([1, 2])], dtype=object), array([1, list([1, 2])], dtype=object)) . a[1][0]=200 . a,b . (array([100, list([200, 2])], dtype=object), array([1, list([1, 2])], dtype=object)) . 일반적으로 넘파이를 이용할때 자주 사용하는 데이터 구조인 행렬, 텐서등을 이용하면 위와 같은 copy모듈은 불필요함 . &#48324;&#47749;, &#48624;, &#52852;&#54588; . - test 함수 작성 . def test(a,b): if id(a) == id(b): print(&quot;별명&quot;) elif id(a) == id(b.base) or id(a.base)==id(b): print(&quot;뷰&quot;) elif (id(a.base)!=id(None) and id(b.base)!=id(None)) and id(a.base) == id(b.base): print(&quot;공통의 base를 가짐&quot;) else: print(&quot;카피, 혹은 아무 관련없는 오브젝트&quot;) . - 잘 동작하나? . (테스트1) . a=np.array([1,2,3,4]) b=a . test(a,b) . 별명 . (테스트2) . a=np.array([1,2,3,4]) b=a.view() . test(a,b) . 뷰 . (테스트3) . a=np.array([1,2,3,4]) b=a.view() c=a.view() . test(b,c) . 공통의 base를 가짐 . test(a,b) . 뷰 . test(a,c) . 뷰 . (테스트4) . a=np.array([1,2,3,4]) b=a.copy() . test(a,b) . 카피, 혹은 아무 관련없는 오브젝트 . - 우리가 사용했던 어떠한 것들이 뷰가 나올지 카피가 나올지 사실 잘 모른다. . a=np.array([1,2,3,4]) b=a[:3] . a . array([1, 2, 3, 4]) . b . array([1, 2, 3]) . test(a,b) . 뷰 . c=a[[0,1,2]] c . array([1, 2, 3]) . test(a,c) . 카피, 혹은 아무 관련없는 오브젝트 . - . a=np.array([[1,2],[3,4]]) a . array([[1, 2], [3, 4]]) . b=a.flatten() c=a.ravel() d=a.reshape(-1) . test(a,b) . 카피, 혹은 아무 관련없는 오브젝트 . test(a,c) . 뷰 . test(a,d) . 뷰 . test(c,d) . 공통의 base를 가짐 . test(b,c) . 카피, 혹은 아무 관련없는 오브젝트 .",
            "url": "https://guebin.github.io/IP2022WIN/2022/01/04/WINIP3.html",
            "relUrl": "/2022/01/04/WINIP3.html",
            "date": " • Jan 4, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "파이썬입문 겨울방학 특강 (2)",
            "content": "- 오늘오전: 자료형, 오브젝트 .. . - 오늘오후: 참조, 얕은복사, 깊은복사 . - 내일오전: 뷰와 카피 . - 내일오후: 개발환경 비교 . &#52280;&#51312;&#50752; &#50640;&#51068;&#47532;&#50612;&#49905; . - 아래의 코드를 관찰하자. . a=[1,2,3] b=a a=a+[4] . 현재 a,b의 출력결과는? . a,b . ([1, 2, 3, 4], [1, 2, 3]) . - 이제 다시 아래의 코드를 관찰하자. . a=[1,2,3] b=a a.append(4) . a,b . ([1, 2, 3, 4], [1, 2, 3, 4]) . - 아래의 코드를 다시 살펴보자. . a=[1,2,3] b=a a.append(4) . a,b라는 변수들은 메모리에 어떻게 저장이 되어있을까? . 상상력을 조금 발휘하면 아래와 같이 여길 수 있다. . (1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. . (2) 아래를 실행하였을 경우 . a=[1,2,3] . 메모리주소1에 존재하는 방을 a라고 하고, 그 방에 [1,2,3]을 넣는다. | . (3) 아래를 실행하였을 경우 . b=a . 메모리주소38에 존재하는 방을 b라고 하고, 그 방에 a를 넣어야하는데, a는 [1,2,3]이니까 [1,2,3]을 넣는다. | . (4) 아래를 실행하면 . a.append(4) . 방 a로가서 [1,2,3]을 [1,2,3,4]로 바꾼다. | 그리고 방 b에는 아무것도 하지 않는다. | . - R에서는 맞는 비유인데, 파이썬은 적절하지 않은 비유이다. . id(a) . 139851743661952 . id(b) . 139851743661952 . 실제로는 a,b가 저장된 메모리 주소가 동일함 . - 파이썬에서는 아래가 더 적절한 비유이다. . (1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. . (2) 아래를 실행하였을 경우 . a=[1,2,3] . 메모리주소139851743661952에서 [1,2,3]을 생성해요 | 방 139851743661952의 방문에 a라는 포스트잇을 붙인다. | 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙은 방을 찾아가면 된다. | . (3) 아래를 실행하였을 경우 . b=a . a라는 포스트잇이 있는데, a라는 포스트잇이랑 b라는 포스트잇과 같은 효과를 주도록 한다. | 쉽게말하면 b라는 포스트잇을 방 139851743661952의 방문에 붙인다는 이야기. | 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙어 있거나 b라는 포스트잇이 붙어있는 방을 찾아가면 된다. | . (4) 아래를 실행하면 . a.append(4) . a라는 포스트잇이 붙어있는 방으로 가서, 그 내용물 append함수를 써서 4를 추가하라. 즉 내용물 [1,2,3]을 [1,2,3,4]로 바꾸라. | 같은방에 a,b라는 포스트잇이 모두 붙어있음. 따라서 b라는 포스트잇이 붙은 방을 찾아가서 내용물을 열어보면 [1,2,3,4]가 나온다. | . &#54624;&#45817;&#47928;(=)&#51032; &#51060;&#54644; . - 파이썬에서 할당문을 이해하기 위해서는 언제나 오른쪽을 먼저 읽어야 한다. . 할당문의 오른쪽에서는 객체를 생성하거나 가져옴 | 그 후에 라벨을 붙이듯이 할당문 왼쪽의 변수가 할당문 오른쪽의 객체에 바인딩 된다. (참조) | . - b=a는 . 나는 이미 a가 의미하는게 무엇인지 알고있어. 그런데 그 실체를 b라고도 부르고 싶어. . 라는 것과 같다. 즉 이미 a라고 부르고 있는것을 내가 b라고도 부르고싶다는 의미인데 이는 마치 별명과 같다. (b는 a의 별명, alias) 그리고 이처럼 하나의 오브젝트에 여러개의 이름을 붙이는 것을 에일리어싱이라고 부른다. . - 참조: 하나의 메모리 주소에 변수의 이름을 바인딩하는 것을 참조라고 한다. . - 에일리어싱: 하나의 메모리 주소에 여러개의 변수이름을 바인딩 하는 것을 에일리어싱이라고 한다. . id, value . - 아래의 예제를 살펴보자. . a=[1,2,3] b=a a.append(4) c=[1,2,3,4] . 여기에서 a,b,c는 모두 같은 value를 가진다. . a . [1, 2, 3, 4] . b . [1, 2, 3, 4] . c . [1, 2, 3, 4] . 하지만 그 id까지 같은 것은 아니다. . id(a), id(b), id(c) . (139851739924096, 139851739924096, 139851742724800) . - 이제 다시 아래의 코드를 살펴보자. . a=[1,2,3] b=a a=[1,2,3]+[4] . a,b . ([1, 2, 3, 4], [1, 2, 3]) . id(a),id(b) . (139851742145536, 139851743152000) . &#51060;&#53552;&#45789; . - 참조의 개념은 확실하게 알겠음. 이제 아래의 예제를 살펴보자. . a=1+2 id(a) . 139852067748208 . b=4-1 id(b) . 139852067748208 . 이게 왜 똑같지..? . (해설) 파이썬의 경우 효율성을 위해서 -5~256까지의 정수를 미리 저장해둠. . id(22) . 139852067748816 . - 이제 아래의 예제를 살펴보자. . a=1+2021 id(a) . 139851741177168 . b=2023-1 id(b) . 139851741254000 . id(2022) . 139851741253744 . copy (shallow copy) . - 아래의 예제를 살펴보자. (참조를 제대로 이해했다면 아래의 예제는 자연스럽게 이해가능) . l1 = [3, [66,55,44]] l2 = l1 . id(l1),id(l2) . (139851740541056, 139851740541056) . l1[0]=4 . l1 . [4, [66, 55, 44]] . l2 . [4, [66, 55, 44]] . l2.append(5) . l2 . [4, [66, 55, 44], 5] . l1 . [4, [66, 55, 44], 5] . - R과 같은 방식으로 =를 사용하고 싶다면? . l1 = [3, [66,55,44]] l2 = l1.copy() . id(l1),id(l2) ## 드디어 주소가 달라졌다. . (139851741022656, 139851741533184) . l1[0]=100 . l1 . [100, [66, 55, 44]] . l2 . [3, [66, 55, 44]] . - 이제 다 이해했다고 생각했는데.. . l1 = [3,[66,55,44]] l2 = l1.copy() . id(l1),id(l2) . (139851987671936, 139851740745472) . l1[1].append(33) . l1 . [3, [66, 55, 44, 33]] . l2 . [3, [66, 55, 44, 33]] . 왜 또 참조한것마냥 l1과 l2가 같이 바뀌고 있지? . - 위의 문제를 해설하여 보자. (주의: 해설이 좀 길어요) . (상황1) . a=2222 b=2222 . id(a),id(b) . (139851743195216, 139851743195440) . 현재 메모리 상황 . -5~256 까지의 숫자는 어딘가에 저장되어 있음 | 2222라는 오브젝트가 어떤공간에 생성되고 그 공간에 a라는 라벨이 붙음 | 2222라는 오브젝트가 어떤공간에 생성되고 그 공간에 b라는 라벨이 붙음 | . 즉 -5~256 이외의 2개의 메모리 공간을 추가적으로 사용 . (상황2) 이제 아래의 상황을 살펴보자 . a=[1,2,2222] b=[1,2,2222] . id(a),id(b) . (139851740010880, 139851742120448) . id(a[0]),id(b[0]) . (139852067748144, 139852067748144) . id(a[1]),id(b[1]) . (139852067748176, 139852067748176) . id(a[2]),id(b[2]) . (139851743195248, 139851743195568) . a.append(4) . a . [1, 2, 2222, 4] . b . [1, 2, 2222] . 해설을 다시 해보면 아래와 같다. . -5~256까지의 숫자가 메모리에 저장되어 있다. | 2222가 어떤 공간에 저장된다. 공간 X1이라고 하자. | 리스트오브젝트가 만들어지고 원소로 1,2,2222를 가짐. 이 공간을 a라고 부름. | 2222가 어떤 공간에 저장된다. 공간을 X2라고 하자. | 리스트오브젝트가 만들어지고 원소로 1,2,2222를 가짐. 이 공간을 b라고 부름. | 공간 a에 원소 4를 추가시킴. | . 즉 -5~256이외에 4개의 메모리 공간을 추가사용 . X1: 2222 | X2: 2222 | a = 1,2,공간X1의값 --&gt; append를 쓰면 1,2,공간X1의값,4 | b = 1,2,공간X2의값 | . (상황3) . l1 = [3,[66,55,44]] l2 = l1.copy() l1[1].append(33) . 해설을 해보자. . -5~256까지의 숫자가 메모리에 저장되어 있다. | [66,55,44]가 저장되는 공간이 생성됨. 이 공간을 X1 | [3,[66,55,44]]가 저장되는 공간이 생성됨. 이 공간을 l1 | 공간 l2가 만들어지고 그 안에 리스트가 있음. 리스트의 첫번째원소는 3, 두번째원소는 공간X1의 값. | 공간X1의 값에 접근하여 33을 추가함. 즉 공간 X1의 값을 [66,55,44]에서 [66,55,44,33]으로 변경 | . 따라서 . l1 = [3, 공간X1의 값] | l2 = [3, 공간X2의 값] | l1[1].append(33) 을 하는 순간 공간 x1의 값이 [66,55,44]에서 [66,55,44,33]으로 변경 | . - 결국 아래의 2개의 코드는 다른 코드임 . a=[2222,3333] b=[2222,3333] . id(a),id(b) . (139851750028864, 139851740431104) . id(a[0]),id(b[0]) . (139851743196432, 139851743196336) . id(a[1]),id(b[1]) . (139851743196240, 139851743196752) . a=[2222,3333] b=a.copy() . id(a),id(b) . (139851739986112, 139851739526784) . id(a[0]),id(b[0]) . (139851743196912, 139851743196912) . id(a[1]),id(b[1]) . (139851743196848, 139851743196848) . - 결국 *.copy() 메소드는 깊은곳까지 복사를 하지 않음. (메모리를 너무 아낀다.) . - 사실 그런데 이렇게 해도 평소에는 티가 잘 안난다. . a=[2222,3333] b=a.copy() . a . [2222, 3333] . b . [2222, 3333] . b[1]=4444 . b . [2222, 4444] . id(a),id(b) . (139851740984000, 139851740712640) . id(a[0]),id(b[0]) . (139851743197456, 139851743197456) . id(a[1]),id(b[1]) . (139851743197392, 139851743197488) . shallow copy &#50672;&#49845;&#47928;&#51228; . - 예제1: 아래코드의 결과를 (l1,l2의 값, 메모리상황) 예측하라. 결과가 나오는 이유를 설명하라. . l1= [3,[66,55,44]] ## X1, l1 l2= l1.copy() ## l2 l1[1].append(33) ## . l1,l2 . ([3, [66, 55, 44, 33]], [3, [66, 55, 44, 33]]) . - 예제2: 아래코드의 결과를 (l1,l2의 값, 메모리상황) 예측하라. 결과가 나오는 이유를 설명하라. . l1= [3,[66,55,44]] ## X1, l1 l2= l1.copy() ## l2 l1[1] = l1[1]+[33] ## X2 . l1,l2 . ([3, [66, 55, 44, 33]], [3, [66, 55, 44]]) . - 예제3: 예제2에서 이어서 아래를 실행하라. 아래코드의 결과를 (l1,l2의 값, 메모리상황) 예측하라. 결과가 나오는 이유를 설명하라. . l1[1].remove(33) . l1,l2 . ([3, [66, 55, 44]], [3, [66, 55, 44]]) . - 예제4: 현재 l1,l2의 값을 확인하라. . 예제3에서 이어서 아래를 실행하라. 아래코드의 결과를 (l1,l2의 값, 메모리상황) 예측하라. 결과가 나오는 이유를 설명하라. 결과가 예제1과 다른 이유는? . l1[1].append(33) . l1,l2 . ([3, [66, 55, 44, 33]], [3, [66, 55, 44]]) . - 예제5: 아래코드를 관찰하여 결과를 관찰하라. 결과가 예제1과 같은가 예제2와 같은가? -- 예제1과 같아요 . l1=[3,[66,55,44]] l2=l1.copy() l2[1] += [33] ## l2[1] = l2[1]+[33] . l1,l2 . ([3, [66, 55, 44, 33]], [3, [66, 55, 44, 33]]) . a += [1] 는 새로운 오브젝트를 만드는게 아니고, 기존의 오브젝트를 변형하는 스타일의 코드구나? (마치 메소드처럼) . - 예제6: 아래코드를 실행하고 결과를 관찰하라. 왜 예제5와 다른가? . l1=[3,(66,55,44)] l2=l1.copy() l2[1] += (33,) . l1,l2 . ([3, (66, 55, 44)], [3, (66, 55, 44, 33)]) . (해설) . -5,256까지의 값이 메모리 어딘가에 저장되어 있음. | 추가로 (66,55,44)이 저장될 공간이 필요함. 이 공간을 공간 X1이라 하자. . | [3,공간x1의 값] 의 값이 저장될 공간이 필요함. 이 공간은 l1이라고 하자. . | l2라는 공간을 만들어서 [3,공간x1의값]을 저장 . | 공간X1의 값에 33을 추가하고 싶음. 그런데 공간 X1에 저장된 값은 튜플인데 튜플은 값을 바꿀 수가 없다. 그래서 할수없이 새로운 공간 X2를 만들고 거기에 (66,55,44,33)을 넣고, 그것을 l2의 두번째 원소에 맵핑 . | . 정리하면 아래와 같은 상황임 . 공간 X1: (66,55,44) | 공간 X2: (66,55,44,33) | 공간 l1: [3,공간X1의값] | 공간 l2: [3,공간X2의값] (기존에는 [3,공간X1의값]이었음) | . 기억할것 . - 파이썬은 메모리를 아끼기 위해서 shallow copy라는 이상한 행동을 한다. . - 오묘하게도 [1000,2000,3000,4000,5000,6000]와 같이 0차원 자료형으로만 구성된 리스트라면 문제가 되지 않음. (메모리는 아끼면서 문제가 되지 않는다? 천재인데?) . - 그런데 [[1,2],[3,4]] 와 같이 리스트에 리스트가 포함된 형태라면 문제가 생긴다. (이건 개선이 필요함) . 개선1: 깊은복사 | 개선2: 넘파이 | . deep copy . - 얕은복사가 아니라 내부객체까지 모두 새로 만드는 깊은 복사를 하기위해서는 아래와 같이 copy 모듈을 사용한다. . import copy . - 깊은복사 예제1 . l1 = [3,[66,55,44]] l2 = copy.deepcopy(l1) . id(l1),id(l2) . (139852030311616, 139851739502336) . id(l1[0]),id(l2[0]) . (139852067748208, 139852067748208) . id(l1[1]),id(l2[1]) . (139851739525504, 139851739117696) . l2[1].append(33) . l1 . [3, [66, 55, 44]] . l2 . [3, [66, 55, 44, 33]] . - 깊은복사 예제2 . l1 = [3,[66,[55,44]]] l2 = copy.deepcopy(l1) . id(l1),id(l2) ## shallow copy = 1 level deep copy . (139851739573248, 139851739217024) . id(l1[1]),id(l2[1]) ## (2 level) deep copy . (139851740009024, 139851739501440) . id(l1[1][1]), id(l2[1][1]) ## (3 level) deep copy . (139851738451072, 139851743243584) . l2[1][1].append(33) . l1,l2 . ([3, [66, [55, 44]]], [3, [66, [55, 44, 33]]]) .",
            "url": "https://guebin.github.io/IP2022WIN/2022/01/03/WINIP2.html",
            "relUrl": "/2022/01/03/WINIP2.html",
            "date": " • Jan 3, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "파이썬입문 겨울방학 특강 (1)",
            "content": "- 오늘오전: 자료형, 오브젝트 .. . - 오늘오후: 참조, 얕은복사, 깊은복사 . - 내일오전: 뷰와 카피 . - 내일오후: 개발환경 비교 . a=[1,2,3] . a . [1, 2, 3] . b=a . b . [1, 2, 3] . a.append(4) . a . [1, 2, 3, 4] . b . [1, 2, 3, 4] . 0&#52264;&#50896; &#51088;&#47308;&#54805;&#51032; &#49548;&#44060; . - 0차원 자료형: 하나의 값을 저장할 수 있는 자료형 . - int, bool, float . a=100 . type(a) . int . a=1.2*3 a . 3.5999999999999996 . type(a) . float . a=True b=False . type(a) . bool . - 0차원 자료형이 int, bool, float 3개만 있는 것은 아니다. . a=1+1j b=2-2j . type(a) . complex . c=a+b c . (3-1j) . type(c) . complex . 잘 쓰지 않음 | . 0&#52264;&#50896; &#51088;&#47308;&#54805;&#51032; &#48320;&#54872; . - float $ to$ int . a=3.14122222 a . 3.14122222 . b=int(a) b . 3 . - int $ to$ float . a=3 type(a) . int . b=float(a) type(b) . float . - bool $ to$ int, bool $ to$ float (이게 가능하지 않을것 같지만 사실 가능함) . a=True int(a) . 1 . float(a) . 1.0 . b=False int(b) . 0 . float(b) . 0.0 . - &quot;이런건 변환 못하겠지?&quot; 싶은것도 바꿔줌 . bool(-3.14) . True . 저는 이런걸 쓰지 않아요.. | . - 형변환이 항상 성공하는것은 아님 (규칙은 잘 모르겠음) . float(3+0j) . TypeError Traceback (most recent call last) &lt;ipython-input-48-804a051fe87a&gt; in &lt;module&gt; -&gt; 1 float(3+0j) TypeError: can&#39;t convert complex to float . - 묵시적 형변환 (약간 눈치주는 느낌) . explicit: 온풍기를 좀 키자.. | implicit: 날이 좀 춥지 않어..? (온풍기좀 틀자는 이야기) | . True*1 . 1 . 1을 곱해야하는데..? 너 계속 bool형태로 있을거야?? | . 1*1.0 . 1.0 . 1.0을 곱할건데..? 너 계속 int형으로 있을거야?? | . 1&#52264;&#50896; &#51088;&#47308;&#54805;&#51032; &#49548;&#44060; . - 기본적인 1차원 자료형은 리스트와 튜플이 있다. . a=[1,2,3] ## 리스트 a . [1, 2, 3] . type(a) . list . b=(1,2,3) ## 튜플 b . (1, 2, 3) . type(b) . tuple . - 리스트와 튜플 모두 원소에 접근하기 위해서 []를 사용한다. (R과 동일) . a[0] . 1 . a[1] . 2 . a[2] . 3 . b[0] . 1 . b[1] . 2 . b[2] . 3 . - 리스트는 원소의 값을 바꿀 수 있지만 튜플은 바꿀 수 없다. . a . [1, 2, 3] . a[0]=100 . a . [100, 2, 3] . b . (1, 2, 3) . b[0]=100 . TypeError Traceback (most recent call last) &lt;ipython-input-67-2a3fb166f233&gt; in &lt;module&gt; -&gt; 1 b[0]=100 TypeError: &#39;tuple&#39; object does not support item assignment . - 문자열도 1차원자료형으로 생각한다. (조금 의외임) . a=&#39;guebin&#39; . type(a) . str . a[0] . &#39;g&#39; . a[1] . &#39;u&#39; . - 그밖에 집합, 딕셔너리와 같은 1차원 자료형도 있다. (여기서는 자세히 다루지 않음) . s={1,2,3,4,4} . s . {1, 2, 3, 4} . type(s) . set . d={&#39;a&#39;:123,&#39;b&#39;:234 ,&#39;c&#39;:233} d . {&#39;a&#39;: 123, &#39;b&#39;: 234, &#39;c&#39;: 233} . type(d) . dict . d[&#39;a&#39;] . 123 . d[0] . KeyError Traceback (most recent call last) &lt;ipython-input-93-123a9cc6df61&gt; in &lt;module&gt; -&gt; 1 d[0] KeyError: 0 . - 원소에 접근할 수 있는 자료형인지 없는 자료형인지 파악하는 방법? . dir()을 사용했을 경우 __getitem__ 이 보이면 원소에 접근할 수 있는 자료형임. | . a=[1,2,3] a.__getitem__? . Docstring: x.__getitem__(y) &lt;==&gt; x[y] Type: builtin_function_or_method . a.__getitem__(1) ## a[1] . 2 . &#47532;&#49828;&#53944;&#44277;&#48512; 1&#45800;&#44228; . - 리스트의 선언 . a=[1,2,3] a . [1, 2, 3] . type(a) . list . - 비어있는 리스트를 선언 . a=list() ## 방법1 a . [] . a=[] ## 방법2 a . [] . - 리스트에서 +의 의미 . a=[1,2,3] b=[4,5,6] a+b . [1, 2, 3, 4, 5, 6] . 충격.. 리스트에서는 + 연산자를 쓰면 우리가 상식적으로 생각하는 벡터연산이 수행되지 않음. | . - 리스트에서 *의 의미 . a=[1,2,3] a+a . [1, 2, 3, 1, 2, 3] . a*2 ## a+a?? . [1, 2, 3, 1, 2, 3] . [1]*10 . [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] . - 예제: 비어있는 리스트를 만들고 [1], [2], [3]을 각각 더하여 원소를 추가해보자. . a=[] a . [] . a=a+[1] a . [1] . a=a+[2] a . [1, 2] . a=a+[3] a . [1, 2, 3] . &#47532;&#49828;&#53944;&#44277;&#48512; 2&#45800;&#44228; . - 리스트에서 원소를 추가하는 또 다른 방법 . a = [] a += [1] a += [2] a += [3] a . [1, 2, 3] . - 리스트에서 원소를 추가하는 또 또 다른 방법 . a=[] a . [] . a.append(1) a . [1] . a.append(2) a . [1, 2] . a.append(3) a . [1, 2, 3] . - a.append(1)이라는 문법이 너무 낯설어요 $ to$ 당연해요 . 파이썬 특징: 모든 변수명 뒤에 .을 붙이면 그 변수에 특화된 새로운 기능을 쓸 수 있다. (파이썬에서 변수는 단순히 정보가 담긴 그릇을 의미하는 것이 아니다. 기능이 있다.) | 장점: 초보자라도 눈치껏 문법을 배우기 편하다. | 단점: 처음에는 너무 이해하기 난해함. | . - 마음의 눈 . a.f() = f(a) 로 생각하면 편리함 | a.f(2) = f(a,2) 로 생각하면 편리함. | 이러한 점에서 R의 %&gt;% 연산자와 유사하다고 생각할 수 있음 (사실 약간 다르긴해요) | . - 리스트 특화기능 (=특화함수=메소드) . (append) . a.append? . Signature: a.append(object, /) Docstring: Append object to the end of the list. Type: builtin_function_or_method . a=[1,2,3] a.append(4) a . [1, 2, 3, 4] . (clear) . a.clear? . Signature: a.clear() Docstring: Remove all items from list. Type: builtin_function_or_method . a=[1,2,3] a.clear() a . [] . (copy) . a.copy? . Signature: a.copy() Docstring: Return a shallow copy of the list. Type: builtin_function_or_method . a=[1,2,3] b=a.copy() b . [1, 2, 3] . (count) . a.count? . Signature: a.count(value, /) Docstring: Return number of occurrences of value. Type: builtin_function_or_method . a=[1,1,2,3.14,3.14] a.count(3.14) . 2 . (extend) . a.extend? . Signature: a.extend(iterable, /) Docstring: Extend list by appending elements from the iterable. Type: builtin_function_or_method . a=[1,2,3] b=[1,2,3,4,5,6] a.extend(b) a . [1, 2, 3, 1, 2, 3, 4, 5, 6] . (index) . a.index? . Signature: a.index(value, start=0, stop=9223372036854775807, /) Docstring: Return first index of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a=[1,2,3,3,4,4,5,6] a.index(5) . 6 . (insert) . a.insert? . Signature: a.insert(index, object, /) Docstring: Insert object before index. Type: builtin_function_or_method . a=[1,2,3] a.insert(0,88) a . [88, 1, 2, 3] . (pop) . a.pop? . Signature: a.pop(index=-1, /) Docstring: Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. Type: builtin_function_or_method . a=[1,2,3,4] a.pop() a . [1, 2, 3] . a.pop() a . [1, 2] . a.pop() a . [1] . a.pop() a . [] . (remove) . a.remove? . Signature: a.remove(value, /) Docstring: Remove first occurrence of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a=[1,2,3,44] a.remove(44) . a . [1, 2, 3] . (reverse) . a.reverse? . Signature: a.reverse() Docstring: Reverse *IN PLACE*. Type: builtin_function_or_method . a=[1,2,3] a.reverse() a . [3, 2, 1] . (sort) . a.sort? . Signature: a.sort(*, key=None, reverse=False) Docstring: Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. Type: builtin_function_or_method . a=[1,3,2,4] a.sort() a . [1, 2, 3, 4] . &#47532;&#49828;&#53944;&#44277;&#48512; 3&#45800;&#44228; . &#47532;&#49828;&#53944;&#51032; &#48772;&#49480;&#44284; &#45208;&#45591;&#49480; . - 리스트의 뺄셈: 이런건 없다. . a=[1,2,3,4] a-[1] . TypeError Traceback (most recent call last) &lt;ipython-input-178-fcd9077664c1&gt; in &lt;module&gt; 1 a=[1,2,3,4] -&gt; 2 a-[1] TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . - 리스트의 나눗셈: 이런건 없다. . a=[1,2,3,1,2,3] a/2 . TypeError Traceback (most recent call last) &lt;ipython-input-179-0f405c3ca648&gt; in &lt;module&gt; 1 a=[1,2,3,1,2,3] -&gt; 2 a/2 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . a.append(4) &#50752; a+[4] &#51032; &#52264;&#51060;&#51216;? . - a=a+[4]: a는 변화하지 않음. . a=[1,2,3] a+[4] . [1, 2, 3, 4] . a . [1, 2, 3] . - a.append(4): a자체가 변화함 . a=[1,2,3] a.append(4) a . [1, 2, 3, 4] . - 보통 메소드를 쓰면 a자체가 변화할때가 많다. . a=[1,2,3] a.reverse() a . [3, 2, 1] . - 그런데 모든 메소드가 a를 변화시키는 것은 아니다. (명확한 기준은 없는데 왠지 의미상 a를 변화시킬 필요가 없을 것 같은게 있어요..) . a=[1,2,2,3,4] a.count(2) . 2 . a . [1, 2, 2, 3, 4] . len&#51008; list&#51032; &#50896;&#49548;&#47484; &#49464;&#50612;&#49436; &#47532;&#53556;&#54620;&#45796;. . a=[1,2,3,3] len(a) . 4 . a=[] len(a) . 0 . - 아래는 동작하지 않음. . a=[1,2,3] a.len() . AttributeError Traceback (most recent call last) &lt;ipython-input-192-0f2df5fcd2b1&gt; in &lt;module&gt; 1 a=[1,2,3] -&gt; 2 a.len() AttributeError: &#39;list&#39; object has no attribute &#39;len&#39; . [3]&#44284; 3&#51008; &#45796;&#47476;&#45796; . - 다른점1: [3] 1차원, 3은 0차원 자료형 . a=[3] len(a) . 1 . a=3 len(a) . TypeError Traceback (most recent call last) &lt;ipython-input-195-ef5c313af7eb&gt; in &lt;module&gt; 1 a=3 -&gt; 2 len(a) TypeError: object of type &#39;int&#39; has no len() . - 다른점2: +연산 적용시 차이점 . a=[3] a+[4] . [3, 4] . a=3 a+4 . 7 . a=[3] a+4 . TypeError Traceback (most recent call last) &lt;ipython-input-198-51cc563c823d&gt; in &lt;module&gt; 1 a=[3] -&gt; 2 a+4 TypeError: can only concatenate list (not &#34;int&#34;) to list . a=3 a+[4] . TypeError Traceback (most recent call last) &lt;ipython-input-199-62e0fc93f386&gt; in &lt;module&gt; 1 a=3 -&gt; 2 a+[4] TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;list&#39; . &#47532;&#49828;&#53944;&#51032; &#50896;&#49548;&#45716; &#50612;&#46496;&#54620; &#54805;&#53468;&#46020; &#44032;&#45733;&#54616;&#45796;. . - 예제1 . a=[True,3,3.14] a . [True, 3, 3.14] . type(a[0]) . bool . type(a[1]) . int . type(a[2]) . float . 예제1에 대한 디스커션 . 리스트에 포함된 3개의 원소가 모두 다른 자료형을 가지고 있음. | 즉 원소들이 형변환 되지 않음. (Python의 list는 R에서의 벡터보다 리스트에 가까운 느낌이다) | . - 예제2 . a=[[True,3,3.14],True,[3],3] a . [[True, 3, 3.14], True, [3], 3] . 예제2에 대한 디스커션 . 첫번째 원소는 리스트 (1차원) | 두번째 원소는 bool (0차원) | 세번째 원소는 길이가 1인 리스트 (1차원) | 네번째 원소는 int (0차원) | . &#51473;&#52393;&#47532;&#49828;&#53944; . A=[[1,2,3],[4,5,6],[7,8,9]] A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . - A는 아래와 같은 매트릭스로 생각할 수 있다. . ${ bf A} = begin{bmatrix} 1 &amp; 2 &amp; 3 4 &amp; 5 &amp; 6 7 &amp; 8 &amp; 9 end{bmatrix}$ . - ${ bf A}$에서 (1,1)의 원소를 뽑고싶다! = 1을 뽑고싶음 . A[0,0] . TypeError Traceback (most recent call last) &lt;ipython-input-210-da4621a80edb&gt; in &lt;module&gt; -&gt; 1 A[0,0] TypeError: list indices must be integers or slices, not tuple . 실패 | . A[0][0] . 1 . 성공 | . - 성공의 이유분석 . A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . A[0] . [1, 2, 3] . A[0][0] . 1 . - ${ bf A}$에서 (2,3)위치의 원소를 뽑아보자. $ to$ 파이썬 인덱스로 치면 (1,2) . A[1][2] . 6 . - 매트릭스는 아니지만 매트릭스 같아! . 1차원 배열을 다차원 배열로 확장할 수 있는 기본아이디어를 제공함 . &#53916;&#54540;&#44277;&#48512; 1&#45800;&#44228; . - 튜플은 ()로 선언한다. . a=(1,2,3) a . (1, 2, 3) . type(a) . tuple . - +로 튜플과 튜플을 합칠 수 있다. . a=(1,2,3) b=(4,5,6) a+b . (1, 2, 3, 4, 5, 6) . - 비어있는 튜플을 선언하는 방법 . a=tuple() a . () . a=() a . () . - 원소가 하나있는 튜플을 만들기 위해서는 아래와 같이 한다. . a=(1,) a . (1,) . a+(2,) . (1, 2) . - 튜플도 리스트와 비슷한 방식으로 원소에 접근한다. . a=(1,2,3) a[0] . 1 . a[1] . 2 . a[2] . 3 . - 튜플은 원소에 접근할 수는 있지만 내용을 바꿀 수는 없다. . a=(1,2,3) a[0] . 1 . a[0]=100 . TypeError Traceback (most recent call last) &lt;ipython-input-232-f96ffea17930&gt; in &lt;module&gt; -&gt; 1 a[0]=100 TypeError: &#39;tuple&#39; object does not support item assignment . - 예제: 빈튜플을 만들어보고 (1,) (2,) (3,) 을 더하여 원소를 추가해보자. . a=() a . () . a=a+(1,)+(2,)+(3,) a . (1, 2, 3) . - 아래와 같은 방식도 가능 . a = () a += (1,) a += (2,) a += (3,) a . (1, 2, 3) . &#53916;&#54540;&#44277;&#48512; 2&#45800;&#44228;: &#53916;&#54540; &#50616;&#54056;&#53433; . - 의미가 명확할때는 ()를 생략할 수 있다. . a = 1,2,3,4,5 a . (1, 2, 3, 4, 5) . 1,2,3 . (1, 2, 3) . 1&#52264;&#50896;&#51088;&#47308;&#54805;&#51032; &#48320;&#54872; . - 리스트를 튜플로 . tuple([1,2,3]) . (1, 2, 3) . - 튜플을 리스트로 . list((1,2,3)) . [1, 2, 3] . numpy . 파이썬은 그렇게 좋은 계산성능을 보유하고 있지 않음 . - 놀라운점1: pi가 없음 . pi . NameError Traceback (most recent call last) &lt;ipython-input-241-f84ab820532c&gt; in &lt;module&gt; -&gt; 1 pi NameError: name &#39;pi&#39; is not defined . - 놀라운점2: sqrt가 없다. . sqrt(2) . NameError Traceback (most recent call last) &lt;ipython-input-242-66e338417901&gt; in &lt;module&gt; -&gt; 1 sqrt(2) NameError: name &#39;sqrt&#39; is not defined . - 사칙연산빼고 되는게 없는것 같은데? . log(10) . NameError Traceback (most recent call last) &lt;ipython-input-243-8fe8026424a0&gt; in &lt;module&gt; -&gt; 1 log(10) NameError: name &#39;log&#39; is not defined . exp(1) . NameError Traceback (most recent call last) &lt;ipython-input-244-a9c50c82dfa5&gt; in &lt;module&gt; -&gt; 1 exp(1) NameError: name &#39;exp&#39; is not defined . sin(0) . NameError Traceback (most recent call last) &lt;ipython-input-245-afbcc558f753&gt; in &lt;module&gt; -&gt; 1 sin(0) NameError: name &#39;sin&#39; is not defined . numpy&#47484; &#50416;&#47732; &#54028;&#51060;&#50028;&#51008; &#51339;&#51008; &#44228;&#49328;&#44592;&#44032; &#46108;&#45796;. . 사용법: library(tidyverse)와 비슷하게 import numpy 를 하면 된다. | . import numpy . numpy.pi . 3.141592653589793 . numpy.sqrt(2) . 1.4142135623730951 . numpy.exp(1) . 2.718281828459045 . numpy.log(2.718281828459045) . 1.0 . numpy.sin(0) . 0.0 . - numpy를 모두 치는 것이 불편함 $ to$ 줄여서 약어로 쓰고싶다. . import numpy as np . np.sqrt(2) . 1.4142135623730951 . np.exp(1) . 2.718281828459045 . np.log(2.718281828459045) . 1.0 . np.sin(0) . 0.0 . numpy &#44277;&#48512;: 1&#45800;&#44228; . - numpy.ndarray 자료형을 만드는 방법 . a=[1,2,3] b=np.array(a) b . array([1, 2, 3]) . - numpy를 사용하면 R과 유사한 환경이 만들어짐 . a+1 . TypeError Traceback (most recent call last) &lt;ipython-input-265-98b939904c8e&gt; in &lt;module&gt; -&gt; 1 a+1 TypeError: can only concatenate list (not &#34;int&#34;) to list . b+1 . array([2, 3, 4]) . np.sqrt(b) . array([1. , 1.41421356, 1.73205081]) . np.log(b) . array([0. , 0.69314718, 1.09861229]) . np.sin(b) . array([0.84147098, 0.90929743, 0.14112001]) . np.exp(b) . array([ 2.71828183, 7.3890561 , 20.08553692]) . ((b+1)+2)/3 . array([1.33333333, 1.66666667, 2. ]) .",
            "url": "https://guebin.github.io/IP2022WIN/2022/01/03/WINIP1.html",
            "relUrl": "/2022/01/03/WINIP1.html",
            "date": " • Jan 3, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://guebin.github.io/IP2022WIN/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/IP2022WIN/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}